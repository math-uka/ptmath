<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>全等三角形判斷工具</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        #buttons button {
            margin: 5px;
        }
        #buttons button.active {
            background-color: lightgreen;
        }
        table {
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid black;
            padding: 5px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="400"></canvas>
    <div id="buttons">
        <button id="btn-ab-de" onclick="toggleConstraint('AB=DE')">AB=DE</button>
        <button id="btn-ac-df" onclick="toggleConstraint('AC=DF')">AC=DF</button>
        <button id="btn-bc-ef" onclick="toggleConstraint('BC=EF')">BC=EF</button>
        <button id="btn-anglea-angled" onclick="toggleConstraint('angleA=angleD')">角A=角D</button>
        <button id="btn-angleb-anglee" onclick="toggleConstraint('angleB=angleE')">角B=角E</button>
        <button id="btn-anglec-anglef" onclick="toggleConstraint('angleC=angleF')">角C=角F</button>
    </div>
    <table id="table">
        <thead>
            <tr><th>屬性</th><th>三角形ABC</th><th>三角形DEF</th></tr>
        </thead>
        <tbody>
            <tr><td>AB / DE</td><td id="ab"></td><td id="de"></td></tr>
            <tr><td>AC / DF</td><td id="ac"></td><td id="df"></td></tr>
            <tr><td>BC / EF</td><td id="bc"></td><td id="ef"></td></tr>
            <tr><td>角A / 角D</td><td id="angleA"></td><td id="angleD"></td></tr>
            <tr><td>角B / 角E</td><td id="angleB"></td><td id="angleE"></td></tr>
            <tr><td>角C / 角F</td><td id="angleC"></td><td id="angleF"></td></tr>
        </tbody>
    </table>
    <div id="message" style="font-size: 20px; color: red;"></div>

    <script>
        // 固定三角形ABC的點，設定為SSA反例
        const A = {x: 100, y: 100};
        const C = {x: 200, y: 100};
        const theta = Math.PI / 6; // 30 degrees
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        const b_len = distance(A, C); // 100
        const a_len = 60;
        const disc = a_len ** 2 - b_len ** 2 * sinTheta ** 2;
        const sqrtDisc = Math.sqrt(disc);
        const c1 = b_len * cosTheta + sqrtDisc; // 較長的邊
        const B = {x: A.x + c1 * cosTheta, y: A.y + c1 * sinTheta};

        // 可拖動三角形DEF的點，初始設定相同
        let D = {x: 400, y: 100};
        let F = {x: 500, y: 100};
        let E = {x: D.x + c1 * cosTheta, y: D.y + c1 * sinTheta};

        // 活躍約束
        const activeConstraints = new Set();

        // 選中的點
        let selectedPoint = null;

        // 容差
        const tolerance = 0.1;

        // 是否鎖定全等
        let isCongruentLocked = false;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // 計算距離
        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        // 計算角度（使用餘弦定理）
        function getAngle(p1, p2, p3) { // 角度在p1
            const a = distance(p2, p3);
            const b = distance(p1, p3);
            const c = distance(p1, p2);
            if (a === 0 || b === 0 || c === 0) return 0;
            let cos = (b ** 2 + c ** 2 - a ** 2) / (2 * b * c);
            cos = Math.max(Math.min(cos, 1), -1);
            return Math.acos(cos) * (180 / Math.PI);
        }

        // 向量計算
        function vector(p1, p2) {
            return {x: p2.x - p1.x, y: p2.y - p1.y};
        }

        function vectorLength(v) {
            return Math.sqrt(v.x ** 2 + v.y ** 2);
        }

        function normalizeVector(v) {
            const len = vectorLength(v);
            return len > 0 ? {x: v.x / len, y: v.y / len} : {x: 0, y: 0};
        }

        function scaleVector(v, scale) {
            return {x: v.x * scale, y: v.y * scale};
        }

        function addVector(p, v) {
            return {x: p.x + v.x, y: p.y + v.y};
        }

        function rotateVector(v, angleRad) {
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            return {
                x: v.x * cos - v.y * sin,
                y: v.x * sin + v.y * cos
            };
        }

        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }

        function crossProduct(v1, v2) {
            return v1.x * v2.y - v1.y * v2.x;
        }

        // 繪製三角形
        function drawTriangle(points, labels) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.lineTo(points[2].x, points[2].y);
            ctx.closePath();
            ctx.stroke();

            // 標籤
            labels.forEach((label, i) => {
                ctx.fillText(label, points[i].x - 10, points[i].y - 10);
            });
        }

        // 更新表格和消息
        function updateTableAndMessage() {
            // 計算邊長
            const ab = distance(A, B);
            const ac = distance(A, C);
            const bc = distance(B, C);
            const de = distance(D, E);
            const df = distance(D, F);
            const ef = distance(E, F);

            // 計算角度
            const angle_a = getAngle(A, B, C);
            const angle_b = getAngle(B, A, C);
            const angle_c = getAngle(C, A, B);
            const angle_d = getAngle(D, E, F);
            const angle_e = getAngle(E, D, F);
            const angle_f = getAngle(F, D, E);

            // 更新表格，四捨五入至整數
            document.getElementById('ab').innerText = Math.round(ab);
            document.getElementById('de').innerText = Math.round(de);
            document.getElementById('ac').innerText = Math.round(ac);
            document.getElementById('df').innerText = Math.round(df);
            document.getElementById('bc').innerText = Math.round(bc);
            document.getElementById('ef').innerText = Math.round(ef);
            document.getElementById('angleA').innerText = Math.round(angle_a);
            document.getElementById('angleD').innerText = Math.round(angle_d);
            document.getElementById('angleB').innerText = Math.round(angle_b);
            document.getElementById('angleE').innerText = Math.round(angle_e);
            document.getElementById('angleC').innerText = Math.round(angle_c);
            document.getElementById('angleF').innerText = Math.round(angle_f);

            // 檢查是否全等
            const sidesEqual = Math.abs(ab - de) < tolerance && Math.abs(ac - df) < tolerance && Math.abs(bc - ef) < tolerance;
            const anglesEqual = Math.abs(angle_a - angle_d) < tolerance && Math.abs(angle_b - angle_e) < tolerance && Math.abs(angle_c - angle_f) < tolerance;

            if (isSSA()) {
                document.getElementById('message').innerText = '這是SSA情況, 不保證兩個三角形全等, 可能有兩個不同的三角形';
            } else if (sidesEqual && anglesEqual) {
                document.getElementById('message').innerText = '這兩個三角形全等';
            } else {
                document.getElementById('message').innerText = '';
            }
        }

        // 檢查是否滿足全等條件
        function checkCongruenceConditions() {
            // SSS: 三邊
            if (activeConstraints.has('AB=DE') && activeConstraints.has('AC=DF') && activeConstraints.has('BC=EF')) {
                return true;
            }
            // SAS: 兩邊夾一角
            if (activeConstraints.has('AB=DE') && activeConstraints.has('angleA=angleD') && activeConstraints.has('AC=DF')) {
                return true;
            }
            if (activeConstraints.has('AB=DE') && activeConstraints.has('angleB=angleE') && activeConstraints.has('BC=EF')) {
                return true;
            }
            if (activeConstraints.has('AC=DF') && activeConstraints.has('angleC=angleF') && activeConstraints.has('BC=EF')) {
                return true;
            }
            // ASA: 兩角夾一邊
            if (activeConstraints.has('angleA=angleD') && activeConstraints.has('AB=DE') && activeConstraints.has('angleB=angleE')) {
                return true;
            }
            if (activeConstraints.has('angleA=angleD') && activeConstraints.has('AC=DF') && activeConstraints.has('angleC=angleF')) {
                return true;
            }
            if (activeConstraints.has('angleB=angleE') && activeConstraints.has('BC=EF') && activeConstraints.has('angleC=angleF')) {
                return true;
            }
            // AAS: 兩角一非夾邊
            if (activeConstraints.has('angleA=angleD') && activeConstraints.has('angleB=angleE') && activeConstraints.has('AC=DF')) {
                return true;
            }
            if (activeConstraints.has('angleA=angleD') && activeConstraints.has('angleB=angleE') && activeConstraints.has('BC=EF')) {
                return true;
            }
            if (activeConstraints.has('angleA=angleD') && activeConstraints.has('angleC=angleF') && activeConstraints.has('AB=DE')) {
                return true;
            }
            if (activeConstraints.has('angleA=angleD') && activeConstraints.has('angleC=angleF') && activeConstraints.has('BC=EF')) {
                return true;
            }
            if (activeConstraints.has('angleB=angleE') && activeConstraints.has('angleC=angleF') && activeConstraints.has('AB=DE')) {
                return true;
            }
            if (activeConstraints.has('angleB=angleE') && activeConstraints.has('angleC=angleF') && activeConstraints.has('AC=DF')) {
                return true;
            }
            return false;
        }

        function isSSA() {
            let sideCount = 0;
            if (activeConstraints.has('AB=DE')) sideCount++;
            if (activeConstraints.has('AC=DF')) sideCount++;
            if (activeConstraints.has('BC=EF')) sideCount++;
            let angleCount = 0;
            if (activeConstraints.has('angleA=angleD')) angleCount++;
            if (activeConstraints.has('angleB=angleE')) angleCount++;
            if (activeConstraints.has('angleC=angleF')) angleCount++;
            return sideCount === 2 && angleCount === 1 && !checkCongruenceConditions();
        }

        // 使DEF全等於ABC
        function makeCongruent() {
            // 複製ABC的形狀到DEF，以D為基準
            const vec_ab = vector(A, B);
            const vec_ac = vector(A, C);
            E = addVector(D, vec_ab);
            F = addVector(D, vec_ac);
        }

        // 應用約束調整
        function applyConstraints() {
            if (isSSA()) {
                applySSAConstraints();
            } else {
                for (let i = 0; i < 20; i++) {
                    activeConstraints.forEach(constraint => {
                        adjustForConstraint(constraint);
                    });
                }
            }
        }

        function applySSAConstraints() {
            let angleConstraint = null;
            if (activeConstraints.has('angleA=angleD')) angleConstraint = 'angleA=angleD';
            else if (activeConstraints.has('angleB=angleE')) angleConstraint = 'angleB=angleE';
            else if (activeConstraints.has('angleC=angleF')) angleConstraint = 'angleC=angleF';
            if (!angleConstraint) return;

            let vertex, p, q, targetAngle, adjTarget, oppTarget;
            if (angleConstraint === 'angleA=angleD') {
                vertex = D;
                targetAngle = getAngle(A, B, C);
                oppTarget = distance(B, C);
                if (activeConstraints.has('AB=DE')) {
                    adjTarget = distance(A, B);
                    p = E;
                    q = F;
                } else if (activeConstraints.has('AC=DF')) {
                    adjTarget = distance(A, C);
                    p = F;
                    q = E;
                }
            } else if (angleConstraint === 'angleB=angleE') {
                vertex = E;
                targetAngle = getAngle(B, A, C);
                oppTarget = distance(A, C);
                if (activeConstraints.has('AB=DE')) {
                    adjTarget = distance(A, B);
                    p = D;
                    q = F;
                } else if (activeConstraints.has('BC=EF')) {
                    adjTarget = distance(B, C);
                    p = F;
                    q = D;
                }
            } else if (angleConstraint === 'angleC=angleF') {
                vertex = F;
                targetAngle = getAngle(C, A, B);
                oppTarget = distance(A, B);
                if (activeConstraints.has('AC=DF')) {
                    adjTarget = distance(A, C);
                    p = D;
                    q = E;
                } else if (activeConstraints.has('BC=EF')) {
                    adjTarget = distance(B, C);
                    p = E;
                    q = D;
                }
            }

            if (!vertex || !p || !q) return;

            // 設定相鄰邊長度
            const currentAdj = distance(vertex, p);
            if (Math.abs(currentAdj - adjTarget) > tolerance) {
                const vec_vp = vector(vertex, p);
                const scale = adjTarget / currentAdj;
                p.x = vertex.x + vec_vp.x * scale;
                p.y = vertex.y + vec_vp.y * scale;
            }

            // 計算
            const vec_vp = vector(vertex, p);
            const unit_vp = normalizeVector(vec_vp);
            const current_vec_vq = vector(vertex, q);
            const cross = crossProduct(vec_vp, current_vec_vq);
            const sign = cross >= 0 ? 1 : -1;
            const target_rad = targetAngle * (Math.PI / 180);
            const unit_dir = rotateVector(unit_vp, sign * target_rad);
            const sin_theta = Math.sin(target_rad);
            const adj_len = distance(vertex, p);
            const opp_len = oppTarget;
            const disc = opp_len ** 2 - adj_len ** 2 * sin_theta ** 2;
            if (disc < 0) return;
            const sqrt_disc = Math.sqrt(disc);
            const cos_theta = Math.cos(target_rad);
            const t1 = adj_len * cos_theta + sqrt_disc;
            const t2 = adj_len * cos_theta - sqrt_disc;
            let possibleQs = [];
            if (t1 > 0) {
                possibleQs.push(addVector(vertex, scaleVector(unit_dir, t1)));
            }
            if (t2 > 0) {
                possibleQs.push(addVector(vertex, scaleVector(unit_dir, t2)));
            }
            if (possibleQs.length === 0) return;
            let minDist = Infinity;
            let chosenQ = null;
            possibleQs.forEach(pos => {
                const dist = distance(pos, q);
                if (dist < minDist) {
                    minDist = dist;
                    chosenQ = pos;
                }
            });
            if (chosenQ) {
                q.x = chosenQ.x;
                q.y = chosenQ.y;
            }
        }

        // 調整特定約束
        function adjustForConstraint(constraint) {
            switch (constraint) {
                case 'AB=DE':
                    const ab_len = distance(A, B);
                    const de_len = distance(D, E);
                    if (Math.abs(ab_len - de_len) > tolerance) {
                        const vec_de = vector(D, E);
                        const scale = ab_len / de_len;
                        E.x = D.x + vec_de.x * scale;
                        E.y = D.y + vec_de.y * scale;
                    }
                    break;
                case 'AC=DF':
                    const ac_len = distance(A, C);
                    const df_len = distance(D, F);
                    if (Math.abs(ac_len - df_len) > tolerance) {
                        const vec_df = vector(D, F);
                        const scale = ac_len / df_len;
                        F.x = D.x + vec_df.x * scale;
                        F.y = D.y + vec_df.y * scale;
                    }
                    break;
                case 'BC=EF':
                    const bc_len = distance(B, C);
                    const ef_len = distance(E, F);
                    if (Math.abs(bc_len - ef_len) > tolerance) {
                        const vec_ef = vector(E, F);
                        const scale = bc_len / ef_len;
                        F.x = E.x + vec_ef.x * scale;
                        F.y = E.y + vec_ef.y * scale;
                    }
                    break;
                case 'angleA=angleD':
                    const target_d = getAngle(A, B, C);
                    const vec_de = vector(D, E);
                    let vec_df = vector(D, F);
                    const dot_d = dotProduct(vec_de, vec_df);
                    const cross_d = crossProduct(vec_de, vec_df);
                    const current_signed_rad_d = Math.atan2(cross_d, dot_d);
                    const sign_d = cross_d >= 0 ? 1 : -1;
                    const target_signed_rad_d = sign_d * (target_d * Math.PI / 180);
                    const diff_rad_d = target_signed_rad_d - current_signed_rad_d;
                    vec_df = rotateVector(vec_df, diff_rad_d);
                    F = addVector(D, vec_df);
                    break;
                case 'angleB=angleE':
                    const target_e = getAngle(B, A, C);
                    const vec_ed = vector(E, D);
                    let vec_ef = vector(E, F);
                    const dot_e = dotProduct(vec_ed, vec_ef);
                    const cross_e = crossProduct(vec_ed, vec_ef);
                    const current_signed_rad_e = Math.atan2(cross_e, dot_e);
                    const sign_e = cross_e >= 0 ? 1 : -1;
                    const target_signed_rad_e = sign_e * (target_e * Math.PI / 180);
                    const diff_rad_e = target_signed_rad_e - current_signed_rad_e;
                    vec_ef = rotateVector(vec_ef, diff_rad_e);
                    F = addVector(E, vec_ef);
                    break;
                case 'angleC=angleF':
                    const target_f = getAngle(C, A, B);
                    const vec_fd = vector(F, D);
                    let vec_fe = vector(F, E);
                    const dot_f = dotProduct(vec_fd, vec_fe);
                    const cross_f = crossProduct(vec_fd, vec_fe);
                    const current_signed_rad_f = Math.atan2(cross_f, dot_f);
                    const sign_f = cross_f >= 0 ? 1 : -1;
                    const target_signed_rad_f = sign_f * (target_f * Math.PI / 180);
                    const diff_rad_f = target_signed_rad_f - current_signed_rad_f;
                    vec_fe = rotateVector(vec_fe, diff_rad_f);
                    E = addVector(F, vec_fe);
                    break;
            }
        }

        // 切換約束
        function toggleConstraint(constraint) {
            const btnId = `btn-${constraint.replace('=', '-').toLowerCase()}`;
            const btn = document.getElementById(btnId);
            if (activeConstraints.has(constraint)) {
                activeConstraints.delete(constraint);
                btn.classList.remove('active');
            } else {
                activeConstraints.add(constraint);
                btn.classList.add('active');
                adjustForConstraint(constraint);
            }
            // 檢查是否鎖定全等
            isCongruentLocked = checkCongruenceConditions();
            if (isCongruentLocked) {
                makeCongruent();
            }
            draw();
        }

        // 檢查是否靠近點
        function isNearPoint(x, y, p) {
            return distance({x, y}, p) < 10;
        }

        // 繪製
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 繪製ABC
            drawTriangle([A, B, C], ['A', 'B', 'C']);

            // 繪製DEF
            drawTriangle([D, E, F], ['D', 'E', 'F']);

            updateTableAndMessage();
        }

        // 事件
        let prevMousePos = null;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isNearPoint(x, y, D)) selectedPoint = D;
            else if (isNearPoint(x, y, E)) selectedPoint = E;
            else if (isNearPoint(x, y, F)) selectedPoint = F;

            prevMousePos = {x, y};
        });

        canvas.addEventListener('mousemove', (e) => {
            if (selectedPoint) {
                const rect = canvas.getBoundingClientRect();
                const newX = e.clientX - rect.left;
                const newY = e.clientY - rect.top;

                if (isCongruentLocked) {
                    // 平移整個三角形
                    const dx = newX - prevMousePos.x;
                    const dy = newY - prevMousePos.y;
                    D.x += dx;
                    D.y += dy;
                    E.x += dx;
                    E.y += dy;
                    F.x += dx;
                    F.y += dy;
                } else {
                    // 正常拖動選中點
                    selectedPoint.x = newX;
                    selectedPoint.y = newY;
                    applyConstraints();
                }
                prevMousePos = {x: newX, y: newY};
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            selectedPoint = null;
            prevMousePos = null;
        });

        // 初始繪製
        draw();
    </script>
</body>
</html>