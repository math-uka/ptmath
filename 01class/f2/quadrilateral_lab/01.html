<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallelogram Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            background: #f5f5f7;
            touch-action: none;
            overflow-x: hidden;
        }
        .container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            width: 100%;
            max-width: 1000px;
            gap: 20px;
        }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        canvas {
            border: 1px solid black;
            max-width: 400px;
            max-height: 400px;
            width: 100%;
            touch-action: none;
            background-color: white;
            display: block;
        }
        .table-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            max-width: 300px;
            font-size: 16px;
            background-color: white;
        }
        th, td {
            border: 1px solid black;
            padding: 6px;
            text-align: center;
        }
        button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.active {
            background-color: #ff9500;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        button.active:hover {
            background-color: #e68a00;
        }
        footer {
            margin-top: 20px;
            font-size: 14px;
        }
        @media (max-width: 800px) {
            .container {
                flex-direction: row;
                flex-wrap: wrap;
                align-items: flex-start;
                gap: 10px;
            }
            canvas {
                width: 45%;
                max-width: 200px;
                max-height: 200px;
                height: auto;
            }
            .table-container {
                width: 50%;
                max-width: 200px;
            }
            table {
                font-size: 10px;
                max-width: 100%;
            }
            th, td {
                padding: 3px;
            }
            button {
                font-size: 12px;
                padding: 5px 10px;
            }
            .button-container {
                gap: 6px;
                margin-bottom: 6px;
            }
            h1 {
                font-size: 18px;
                margin: 8px 0;
            }
        }
        @media (max-width: 400px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            canvas {
                width: 100%;
                max-width: 250px;
                max-height: 250px;
            }
            .table-container {
                width: 100%;
                max-width: 250px;
            }
            table {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <h1 style="font-size: 24px; margin: 10px 0;">四邊形分析實驗</h1>
    <div class="button-container">
        <button id="quadrilateralButton" class="active">普通四邊形</button>
        <button id="parallelogramButton">平行四邊形</button>
        <button id="rectangleButton">矩形</button>
        <button id="rhombusButton">菱形</button>
        <button id="squareButton">正方形</button>
        <button id="diagonalButton">對角線</button>
        <button id="exportButton">導出圖像</button>
    </div>
    <div class="container">
        <canvas id="canvas"></canvas>
        <div class="table-container">
            <table id="lengthTable">
                <tr><th>邊長</th><th>值</th></tr>
                <tr><td id="labelAB">AB</td><td id="lengthAB">-</td></tr>
                <tr><td id="labelBC">BC</td><td id="lengthBC">-</td></tr>
                <tr><td id="labelCD">CD</td><td id="lengthCD">-</td></tr>
                <tr><td id="labelAD">AD</td><td id="lengthAD">-</td></tr>
                <tr><td id="labelAC">AC</td><td id="lengthAC">-</td></tr>
                <tr><td id="labelBD">BD</td><td id="lengthBD">-</td></tr>
                <tr><td id="labelAO">AO</td><td id="lengthAO">-</td></tr>
                <tr><td id="labelBO">BO</td><td id="lengthBO">-</td></tr>
                <tr><td id="labelCO">CO</td><td id="lengthCO">-</td></tr>
                <tr><td id="labelDO">DO</td><td id="lengthDO">-</td></tr>
            </table>
            <table id="angleTable" style="display: none;">
                <tr><th>角度</th><th>值</th></tr>
                <tr><td id="labelBAD">∠BAD</td><td id="angleBAD">-</td></tr>
                <tr><td id="labelADC">∠ADC</td><td id="angleADC">-</td></tr>
                <tr><td id="labelDCB">∠DCB</td><td id="angleDCB">-</td></tr>
                <tr><td id="labelCBA">∠CBA</td><td id="angleCBA">-</td></tr>
            </table>
            <button id="toggleButton">角度</button>
        </div>
    </div>
    <footer>
        <p>© 2025 ukawai</p>
    </footer>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const toggleButton = document.getElementById('toggleButton');
        const quadrilateralButton = document.getElementById('quadrilateralButton');
        const parallelogramButton = document.getElementById('parallelogramButton');
        const rectangleButton = document.getElementById('rectangleButton');
        const rhombusButton = document.getElementById('rhombusButton');
        const squareButton = document.getElementById('squareButton');
        const diagonalButton = document.getElementById('diagonalButton');
        const exportButton = document.getElementById('exportButton');
        let gridSize = 20;
        const offsetX = 20, offsetY = 20;
        const gridMax = 20;
        let showAngles = false;
        let showDiagonals = false;
        let currentShape = 'quadrilateral';
        let points = [
            { x: 5, y: 5 },   // A
            { x: 15, y: 5 },  // B
            { x: 15, y: 15 }, // C
            { x: 5, y: 15 }   // D
        ];
        let selectedPoint = null;
        let lastTouchTime = 0;

        function drawCanvas() {
            if (!ctx) {
                console.error('Canvas context not available');
                return;
            }
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function getIntersection(p1, p2, p3, p4) {
            try {
                const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                if (Math.abs(denom) < 1e-4) {
                    return {
                        x: (p1.x + p2.x + p3.x + p4.x) / 4,
                        y: (p1.y + p2.y + p3.y + p4.y) / 4
                    };
                }
                const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;
                const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;
                if (t >= -0.1 && t <= 1.1 && u >= -0.1 && u <= 1.1) {
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }
                return {
                    x: (p1.x + p2.x + p3.x + p4.x) / 4,
                    y: (p1.y + p2.y + p3.y + p4.y) / 4
                };
            } catch (e) {
                console.error('Error in getIntersection:', e);
                return null;
            }
        }

        function calculateLength(p1, p2) {
            try {
                return Math.hypot((p2.x - p1.x) * gridSize, (p2.y - p1.y) * gridSize).toFixed(2);
            } catch (e) {
                console.error('Error in calculateLength:', e);
                return '-';
            }
        }

        function calculateAngle(p1, p2, p3) {
            try {
                const v1x = p1.x - p2.x;
                const v1y = p1.y - p2.y;
                const v2x = p3.x - p2.x;
                const v2y = p3.y - p2.y;
                const dot = v1x * v2x + v1y * v2y;
                const det = v1x * v2y - v1y * v2x;
                let angle = Math.atan2(det, dot) * 180 / Math.PI;
                if (angle < 0) angle += 360;
                return angle.toFixed(2);
            } catch (e) {
                console.error('Error in calculateAngle:', e);
                return '-';
            }
        }

        function calculateArea(p1, p2, p3, p4) {
            try {
                const v1x = p2.x - p1.x;
                const v1y = p2.y - p1.y;
                const v2x = p4.x - p1.x;
                const v2y = p4.y - p1.y;
                return Math.abs(v1x * v2y - v1y * v2x);
            } catch (e) {
                console.error('Error in calculateArea:', e);
                return 0;
            }
        }

        function drawParallelogram() {
            try {
                if (!ctx) {
                    console.error('Canvas context not available in drawParallelogram');
                    return;
                }
                ctx.beginPath();
                ctx.moveTo(points[0].x * gridSize + offsetX, points[0].y * gridSize + offsetY);
                ctx.lineTo(points[1].x * gridSize + offsetX, points[1].y * gridSize + offsetY);
                ctx.lineTo(points[2].x * gridSize + offsetX, points[2].y * gridSize + offsetY);
                ctx.lineTo(points[3].x * gridSize + offsetX, points[3].y * gridSize + offsetY);
                ctx.closePath();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (showDiagonals) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x * gridSize + offsetX, points[0].y * gridSize + offsetY);
                    ctx.lineTo(points[2].x * gridSize + offsetX, points[2].y * gridSize + offsetY);
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(points[1].x * gridSize + offsetX, points[1].y * gridSize + offsetY);
                    ctx.lineTo(points[3].x * gridSize + offsetX, points[3].y * gridSize + offsetY);
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    const inter = getIntersection(points[0], points[2], points[1], points[3]);
                    if (inter) {
                        ctx.beginPath();
                        ctx.arc(inter.x * gridSize + offsetX, inter.y * gridSize + offsetY, 3, 0, 2 * Math.PI);
                        ctx.fillStyle = 'purple';
                        ctx.fill();
                        ctx.fillStyle = 'black';
                        ctx.font = window.innerWidth <= 800 ? '10px Arial' : '16px Arial';
                        ctx.fillText('O', inter.x * gridSize + offsetX + 5, inter.y * gridSize + offsetY - 5);
                    }
                }

                const labels = ['A', 'B', 'C', 'D'];
                points.forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(p.x * gridSize + offsetX, p.y * gridSize + offsetY, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.font = window.innerWidth <= 800 ? '10px Arial' : '16px Arial';
                    ctx.fillText(labels[i], p.x * gridSize + offsetX + 5, p.y * gridSize + offsetY - 5);
                });
            } catch (e) {
                console.error('Error in drawParallelogram:', e);
            }
        }

        function updateTable() {
            try {
                const inter = getIntersection(points[0], points[2], points[1], points[3]);
                const lengths = {
                    AB: calculateLength(points[0], points[1]),
                    BC: calculateLength(points[1], points[2]),
                    CD: calculateLength(points[2], points[3]),
                    AD: calculateLength(points[0], points[3]),
                    AC: calculateLength(points[0], points[2]),
                    BD: calculateLength(points[1], points[3]),
                    AO: inter ? calculateLength(points[0], inter) : '-',
                    BO: inter ? calculateLength(points[1], inter) : '-',
                    CO: inter ? calculateLength(points[2], inter) : '-',
                    DO: inter ? calculateLength(points[3], inter) : '-'
                };

                const angles = {
                    BAD: calculateAngle(points[1], points[0], points[3]),
                    ADC: calculateAngle(points[0], points[3], points[2]),
                    DCB: calculateAngle(points[3], points[2], points[1]),
                    CBA: calculateAngle(points[2], points[1], points[0])
                };

                // 收集值並過濾掉 '-'
                const lengthValues = Object.values(lengths).filter(v => v !== '-');
                const angleValues = Object.values(angles).filter(v => v !== '-');

                // 計算每個值的出現次數
                const lengthCounts = {};
                const angleCounts = {};
                lengthValues.forEach(val => {
                    lengthCounts[val] = (lengthCounts[val] || 0) + 1;
                });
                angleValues.forEach(val => {
                    angleCounts[val] = (angleCounts[val] || 0) + 1;
                });

                // 僅為出現次數大於 1 的值分配顏色
                const lengthColors = {};
                const angleColors = {};
                const colors = ['#f06292', '#4fc3f7', '#81c784', '#fff176', '#ba68c8', '#bcaaa4'];
                let colorIndex = 0;

                Object.keys(lengthCounts).forEach(val => {
                    if (lengthCounts[val] > 1) {
                        lengthColors[val] = colors[colorIndex % colors.length];
                        colorIndex++;
                    }
                });
                Object.keys(angleCounts).forEach(val => {
                    if (angleCounts[val] > 1) {
                        angleColors[val] = colors[colorIndex % colors.length];
                        colorIndex++;
                    }
                });

                // 更新邊長表格，包括標籤格子
                for (const [key, value] of Object.entries(lengths)) {
                    const valueElement = document.getElementById(`length${key}`);
                    const labelElement = document.getElementById(`label${key}`);
                    if (valueElement) {
                        valueElement.textContent = value;
                        valueElement.style.backgroundColor = value !== '-' && lengthColors[value] ? lengthColors[value] : '';
                    }
                    if (labelElement) {
                        labelElement.style.backgroundColor = value !== '-' && lengthColors[value] ? lengthColors[value] : '';
                    }
                }

                // 更新角度表格，包括標籤格子
                for (const [key, value] of Object.entries(angles)) {
                    const valueElement = document.getElementById(`angle${key}`);
                    const labelElement = document.getElementById(`label${key}`);
                    if (valueElement) {
                        valueElement.textContent = value !== '-' ? `${value}°` : '-';
                        valueElement.style.backgroundColor = value !== '-' && angleColors[value] ? angleColors[value] : '';
                    }
                    if (labelElement) {
                        labelElement.style.backgroundColor = value !== '-' && angleColors[value] ? angleColors[value] : '';
                    }
                }

                document.getElementById('lengthTable').style.display = showAngles ? 'none' : '';
                document.getElementById('angleTable').style.display = showAngles ? '' : 'none';
            } catch (e) {
                console.error('Error in updateTable:', e);
            }
        }

        function toggleDisplay() {
            showAngles = !showAngles;
            toggleButton.textContent = showAngles ? '邊長' : '角度';
            updateTable();
        }

        function toggleDiagonals() {
            showDiagonals = !showDiagonals;
            diagonalButton.classList.toggle('active', showDiagonals);
            draw();
        }

        function updateButtonStyles(activeButton) {
            try {
                const buttons = [quadrilateralButton, parallelogramButton, rectangleButton, rhombusButton, squareButton];
                buttons.forEach(button => button.classList.remove('active'));
                activeButton.classList.add('active');
            } catch (e) {
                console.error('Error in updateButtonStyles:', e);
            }
        }

        function setQuadrilateral() {
            currentShape = 'quadrilateral';
            points = [
                { x: 5, y: 5 },   // A
                { x: 15, y: 5 },  // B
                { x: 15, y: 15 }, // C
                { x: 5, y: 15 }   // D
            ];
            updateButtonStyles(quadrilateralButton);
            draw();
        }

        function setParallelogram() {
            currentShape = 'parallelogram';
            points = [
                { x: 5, y: 5 },   // A
                { x: 15, y: 5 },  // B
                { x: 10, y: 15 }, // C
                { x: 0, y: 15 }   // D
            ];
            updateButtonStyles(parallelogramButton);
            draw();
        }

        function setRectangle() {
            currentShape = 'rectangle';
            points = [
                { x: 5, y: 5 },   // A
                { x: 15, y: 5 },  // B
                { x: 15, y: 15 }, // C
                { x: 5, y: 15 }   // D
            ];
            updateButtonStyles(rectangleButton);
            draw();
        }

        function setRhombus() {
            currentShape = 'rhombus';
            points = [
                { x: 10, y: 5 },   // A (top)
                { x: 15, y: 10 },  // B (right)
                { x: 10, y: 15 },  // C (bottom)
                { x: 5, y: 10 }    // D (left)
            ];
            updateButtonStyles(rhombusButton);
            draw();
        }

        function setSquare() {
            currentShape = 'square';
            points = [
                { x: 5, y: 5 },   // A
                { x: 10, y: 5 },  // B
                { x: 10, y: 10 }, // C
                { x: 5, y: 10 }   // D
            ];
            updateButtonStyles(squareButton);
            draw();
        }

        if (toggleButton) toggleButton.addEventListener('click', toggleDisplay);
        if (quadrilateralButton) quadrilateralButton.addEventListener('click', setQuadrilateral);
        if (parallelogramButton) parallelogramButton.addEventListener('click', setParallelogram);
        if (rectangleButton) rectangleButton.addEventListener('click', setRectangle);
        if (rhombusButton) rhombusButton.addEventListener('click', setRhombus);
        if (squareButton) squareButton.addEventListener('click', setSquare);
        if (diagonalButton) diagonalButton.addEventListener('click', toggleDiagonals);

        function updateRhombusPoints(index, newX, newY) {
            let tempPoints = points.map(p => ({ x: p.x, y: p.y }));
            tempPoints[index].x = newX;
            tempPoints[index].y = newY;

            try {
                if (index === 0) {
                    const sideLength = Math.hypot(newX - points[1].x, newY - points[1].y);
                    const midACx = (newX + points[2].x) / 2;
                    const midACy = (newY + points[2].y) / 2;
                    tempPoints[3].x = 2 * midACx - points[1].x;
                    tempPoints[3].y = 2 * midACy - points[1].y;
                    const dxBC = points[2].x - points[1].x;
                    const dyBC = points[2].y - points[1].y;
                    const distBC = Math.hypot(dxBC, dyBC);
                    if (distBC > 0.01) {
                        tempPoints[1].x = points[2].x - (dxBC / distBC) * sideLength;
                        tempPoints[1].y = points[2].y - (dyBC / distBC) * sideLength;
                    } else {
                        tempPoints[1].x = points[2].x - (points[1].x - points[2].x);
                        tempPoints[1].y = points[2].y - (points[1].y - points[2].y);
                    }
                } else if (index === 1) {
                    const sideLength = Math.hypot(points[0].x - newX, points[0].y - newY);
                    const midBDx = (newX + points[3].x) / 2;
                    const midBDy = (newY + points[3].y) / 2;
                    tempPoints[0].x = 2 * midBDx - points[3].x;
                    tempPoints[0].y = 2 * midBDy - points[3].y;
                    const dxCB = points[2].x - newX;
                    const dyCB = points[2].y - newY;
                    const distCB = Math.hypot(dxCB, dyCB);
                    if (distCB > 0.01) {
                        tempPoints[2].x = newX + (dxCB / distCB) * sideLength;
                        tempPoints[2].y = newY + (dyCB / distCB) * sideLength;
                    } else {
                        tempPoints[2].x = newX + (points[2].x - points[1].x);
                        tempPoints[2].y = newY + (points[2].y - points[1].y);
                    }
                } else if (index === 2) {
                    const sideLength = Math.hypot(points[1].x - newX, points[1].y - newY);
                    const midACx = (points[0].x + newX) / 2;
                    const midACy = (points[0].y + newY) / 2;
                    tempPoints[1].x = 2 * midACx - points[0].x;
                    tempPoints[1].y = 2 * midACy - points[0].y;
                    const dxDC = points[3].x - newX;
                    const dyDC = points[3].y - newY;
                    const distDC = Math.hypot(dxDC, dyDC);
                    if (distDC > 0.01) {
                        tempPoints[3].x = newX + (dxDC / distDC) * sideLength;
                        tempPoints[3].y = newY + (dyDC / distDC) * sideLength;
                    } else {
                        tempPoints[3].x = newX + (points[3].x - points[2].x);
                        tempPoints[3].y = newY + (points[3].y - points[2].y);
                    }
                } else if (index === 3) {
                    const sideLength = Math.hypot(points[0].x - newX, points[0].y - newY);
                    const midBDx = (points[1].x + newX) / 2;
                    const midBDy = (points[1].y + newY) / 2;
                    tempPoints[0].x = 2 * midBDx - points[1].x;
                    tempPoints[0].y = 2 * midBDy - points[1].y;
                    const dxCD = points[2].x - newX;
                    const dyCD = points[2].y - newY;
                    const distCD = Math.hypot(dxCD, dyCD);
                    if (distCD > 0.01) {
                        tempPoints[2].x = newX + (dxCD / distCD) * sideLength;
                        tempPoints[2].y = newY + (dyCD / distCD) * sideLength;
                    } else {
                        tempPoints[2].x = newX + (points[2].x - points[3].x);
                        tempPoints[2].y = newY + (points[2].y - points[3].y);
                    }
                }

                const lengths = [
                    Math.hypot(tempPoints[0].x - tempPoints[1].x, tempPoints[0].y - tempPoints[1].y),
                    Math.hypot(tempPoints[1].x - tempPoints[2].x, tempPoints[1].y - tempPoints[2].y),
                    Math.hypot(tempPoints[2].x - tempPoints[3].x, tempPoints[2].y - tempPoints[3].y),
                    Math.hypot(tempPoints[3].x - tempPoints[0].x, tempPoints[3].y - tempPoints[0].y)
                ];
                const maxDiff = Math.max(...lengths) - Math.min(...lengths);
                if (maxDiff > 1.0) {
                    return null;
                }

                const inBounds = tempPoints.every(p => 
                    p.x >= -2 && p.x <= gridMax + 2 && 
                    p.y >= -2 && p.y <= gridMax + 2
                );
                if (!inBounds) {
                    return null;
                }

                const area = calculateArea(tempPoints[0], tempPoints[1], tempPoints[2], tempPoints[3]);
                if (area < 0.05) {
                    return null;
                }

                tempPoints = tempPoints.map(p => ({
                    x: Math.round(p.x),
                    y: Math.round(p.y)
                }));

                return tempPoints;
            } catch (e) {
                console.error('Error in updateRhombusPoints:', e);
                return null;
            }
        }

        function isValidPosition(index, newX, newY) {
            try {
                let tempPoints = points.map(p => ({ x: p.x, y: p.y }));
                tempPoints[index].x = newX;
                tempPoints[index].y = newY;

                if (currentShape === 'rhombus') {
                    const updatedPoints = updateRhombusPoints(index, newX, newY);
                    if (!updatedPoints) {
                        return false;
                    }
                    tempPoints = updatedPoints;
                } else if (currentShape === 'square') {
                    if (index === 0) {
                        const side = Math.max(Math.abs(newX - points[1].x), Math.abs(newY - points[3].y));
                        tempPoints[1].x = newX + side;
                        tempPoints[1].y = newY;
                        tempPoints[2].x = newX + side;
                        tempPoints[2].y = newY + side;
                        tempPoints[3].x = newX;
                        tempPoints[3].y = newY + side;
                    } else if (index === 1) {
                        const side = Math.max(Math.abs(newX - points[0].x), Math.abs(newY - points[2].y));
                        tempPoints[0].x = newX - side;
                        tempPoints[0].y = newY;
                        tempPoints[2].x = newX;
                        tempPoints[2].y = newY + side;
                        tempPoints[3].x = newX - side;
                        tempPoints[3].y = newY + side;
                    } else if (index === 2) {
                        const side = Math.max(Math.abs(newX - points[3].x), Math.abs(newY - points[1].y));
                        tempPoints[0].x = newX - side;
                        tempPoints[0].y = newY - side;
                        tempPoints[1].x = newX;
                        tempPoints[1].y = newY - side;
                        tempPoints[3].x = newX - side;
                        tempPoints[3].y = newY;
                    } else if (index === 3) {
                        const side = Math.max(Math.abs(newX - points[2].x), Math.abs(newY - points[0].y));
                        tempPoints[0].x = newX;
                        tempPoints[0].y = newY - side;
                        tempPoints[1].x = newX + side;
                        tempPoints[1].y = newY - side;
                        tempPoints[2].x = newX + side;
                        tempPoints[2].y = newY;
                    }
                } else if (currentShape === 'rectangle') {
                    if (index === 0) {
                        tempPoints[1].x = newX + (points[1].x - points[0].x);
                        tempPoints[1].y = newY;
                        tempPoints[3].x = newX;
                        tempPoints[3].y = newY + (points[3].y - points[0].y);
                        tempPoints[2].x = tempPoints[1].x;
                        tempPoints[2].y = tempPoints[3].y;
                    } else if (index === 1) {
                        tempPoints[0].x = newX - (points[1].x - points[0].x);
                        tempPoints[0].y = newY;
                        tempPoints[2].x = newX;
                        tempPoints[2].y = newY + (points[2].y - points[1].y);
                        tempPoints[3].x = tempPoints[0].x;
                        tempPoints[3].y = tempPoints[2].y;
                    } else if (index === 2) {
                        tempPoints[1].x = newX;
                        tempPoints[1].y = newY - (points[2].y - points[1].y);
                        tempPoints[3].x = newX - (points[2].x - points[3].x);
                        tempPoints[3].y = newY;
                        tempPoints[0].x = tempPoints[3].x;
                        tempPoints[0].y = tempPoints[1].y;
                    } else if (index === 3) {
                        tempPoints[0].x = newX;
                        tempPoints[0].y = newY - (points[3].y - points[0].y);
                        tempPoints[2].x = newX + (points[2].x - points[3].x);
                        tempPoints[2].y = newY;
                        tempPoints[1].x = tempPoints[2].x;
                        tempPoints[1].y = tempPoints[0].y;
                    }
                } else if (currentShape === 'parallelogram') {
                    if (index === 0) {
                        tempPoints[3].x = tempPoints[2].x + (tempPoints[1].x - newX);
                        tempPoints[3].y = tempPoints[2].y + (tempPoints[1].y - newY);
                    } else if (index === 1) {
                        tempPoints[2].x = tempPoints[3].x + (tempPoints[0].x - newX);
                        tempPoints[2].y = tempPoints[3].y + (tempPoints[0].y - newY);
                    } else if (index === 2) {
                        tempPoints[0].x = tempPoints[1].x + (tempPoints[3].x - newX);
                        tempPoints[0].y = tempPoints[1].y + (tempPoints[3].y - newY);
                    } else if (index === 3) {
                        tempPoints[1].x = tempPoints[0].x + (tempPoints[2].x - newX);
                        tempPoints[1].y = tempPoints[0].y + (tempPoints[2].y - newY);
                    }
                }

                const inBounds = tempPoints.every(p => 
                    p.x >= -2 && p.x <= gridMax + 2 && 
                    p.y >= -2 && p.y <= gridMax + 2
                );

                const area = calculateArea(tempPoints[0], tempPoints[1], tempPoints[2], tempPoints[3]);
                const minArea = 0.05;
                return inBounds && area > minArea;
            } catch (e) {
                console.error('Error in isValidPosition:', e);
                return false;
            }
        }

        function handleStart(e) {
            try {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                const mouseX = (clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (clientY - rect.top) * (canvas.height / rect.height);
                selectedPoint = null;
                points.forEach((p, i) => {
                    const px = p.x * gridSize + offsetX;
                    const py = p.y * gridSize + offsetY;
                    const hitRadius = window.innerWidth <= 800 ? 30 : 20;
                    if (Math.hypot(mouseX - px, mouseY - py) < hitRadius) {
                        selectedPoint = i;
                    }
                });
            } catch (e) {
                console.error('Error in handleStart:', e);
            }
        }

        function handleMove(e) {
            const now = Date.now();
            if (now - lastTouchTime < 50) return;
            lastTouchTime = now;

            if (selectedPoint !== null) {
                try {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    const mouseX = (clientX - rect.left) * (canvas.width / rect.width) - offsetX;
                    const mouseY = (clientY - rect.top) * (canvas.height / rect.height) - offsetY;
                    const newX = Math.max(-2, Math.min(gridMax + 2, Math.round(mouseX / gridSize)));
                    const newY = Math.max(-2, Math.min(gridMax + 2, Math.round(mouseY / gridSize)));

                    if (isValidPosition(selectedPoint, newX, newY)) {
                        if (currentShape === 'rhombus') {
                            const updatedPoints = updateRhombusPoints(selectedPoint, newX, newY);
                            if (updatedPoints) {
                                points = updatedPoints;
                            } else {
                                return;
                            }
                        } else {
                            points[selectedPoint].x = newX;
                            points[selectedPoint].y = newY;

                            if (currentShape === 'square') {
                                if (selectedPoint === 0) {
                                    const side = Math.max(Math.abs(newX - points[1].x), Math.abs(newY - points[3].y));
                                    points[1].x = newX + side;
                                    points[1].y = newY;
                                    points[2].x = newX + side;
                                    points[2].y = newY + side;
                                    points[3].x = newX;
                                    points[3].y = newY + side;
                                } else if (selectedPoint === 1) {
                                    const side = Math.max(Math.abs(newX - points[0].x), Math.abs(newY - points[2].y));
                                    points[0].x = newX - side;
                                    points[0].y = newY;
                                    points[2].x = newX;
                                    points[2].y = newY + side;
                                    points[3].x = newX - side;
                                    points[3].y = newY + side;
                                } else if (selectedPoint === 2) {
                                    const side = Math.max(Math.abs(newX - points[3].x), Math.abs(newY - points[1].y));
                                    points[0].x = newX - side;
                                    points[0].y = newY - side;
                                    points[1].x = newX;
                                    points[1].y = newY - side;
                                    points[3].x = newX - side;
                                    points[3].y = newY;
                                } else if (selectedPoint === 3) {
                                    const side = Math.max(Math.abs(newX - points[2].x), Math.abs(newY - points[0].y));
                                    points[0].x = newX;
                                    points[0].y = newY - side;
                                    points[1].x = newX + side;
                                    points[1].y = newY - side;
                                    points[2].x = newX + side;
                                    points[2].y = newY;
                                }
                            } else if (currentShape === 'rectangle') {
                                if (selectedPoint === 0) {
                                    points[1].x = newX + (points[1].x - points[0].x);
                                    points[1].y = newY;
                                    points[3].x = newX;
                                    points[3].y = newY + (points[3].y - points[0].y);
                                    points[2].x = points[1].x;
                                    points[2].y = points[3].y;
                                } else if (selectedPoint === 1) {
                                    points[0].x = newX - (points[1].x - points[0].x);
                                    points[0].y = newY;
                                    points[2].x = newX;
                                    points[2].y = newY + (points[2].y - points[1].y);
                                    points[3].x = points[0].x;
                                    points[3].y = points[2].y;
                                } else if (selectedPoint === 2) {
                                    points[1].x = newX;
                                    points[1].y = newY - (points[2].y - points[1].y);
                                    points[3].x = newX - (points[2].x - points[3].x);
                                    points[3].y = newY;
                                    points[0].x = points[3].x;
                                    points[0].y = points[1].y;
                                } else if (selectedPoint === 3) {
                                    points[0].x = newX;
                                    points[0].y = newY - (points[3].y - points[0].y);
                                    points[2].x = newX + (points[2].x - points[3].x);
                                    points[2].y = newY;
                                    points[1].x = points[2].x;
                                    points[1].y = points[0].y;
                                }
                            } else if (currentShape === 'parallelogram') {
                                if (selectedPoint === 0) {
                                    points[3].x = points[2].x + (points[1].x - newX);
                                    points[3].y = points[2].y + (points[1].y - newY);
                                } else if (selectedPoint === 1) {
                                    points[2].x = points[3].x + (points[0].x - newX);
                                    points[2].y = points[3].y + (points[0].y - newY);
                                } else if (selectedPoint === 2) {
                                    points[0].x = points[1].x + (points[3].x - newX);
                                    points[0].y = points[1].y + (points[3].y - newY);
                                } else if (selectedPoint === 3) {
                                    points[1].x = points[0].x + (points[2].x - newX);
                                    points[1].y = points[0].y + (points[2].y - newY);
                                }
                            }
                        }

                        draw();
                    }
                } catch (e) {
                    console.error('Error in handleMove:', e);
                }
            }
        }

        function handleEnd(e) {
            try {
                e.preventDefault();
                selectedPoint = null;
            } catch (e) {
                console.error('Error in handleEnd:', e);
            }
        }

        function exportCanvasAsImage() {
            try {
                const dataURL = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = 'quadrilateral.png';
                link.click();
            } catch (e) {
                console.error('Error in exportCanvasAsImage:', e);
                alert('無法導出圖像，請檢查畫布內容。');
            }
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        if (exportButton) exportButton.addEventListener('click', exportCanvasAsImage);

        function resizeCanvas() {
            try {
                const container = document.querySelector('.container');
                if (!container) {
                    console.error('Container not found');
                    return;
                }
                let maxWidth, maxHeight;
                if (window.innerWidth <= 800) {
                    maxWidth = Math.min(200, container.clientWidth * 0.45);
                    maxHeight = maxWidth;
                } else {
                    maxWidth = Math.min(400, container.clientWidth * 0.4);
                    maxHeight = maxWidth;
                }
                canvas.width = maxWidth;
                canvas.height = maxHeight;
                gridSize = (maxWidth - 2 * offsetX) / gridMax;
                if (canvas.width > 0 && canvas.height > 0) {
                    draw();
                }
            } catch (e) {
                console.error('Error in resizeCanvas:', e);
            }
        }

        function draw() {
            try {
                drawCanvas();
                drawParallelogram();
                updateTable();
            } catch (e) {
                console.error('Error in draw:', e);
            }
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', () => {
            resizeCanvas();
            setQuadrilateral();
        });
    </script>
</body>
</html>