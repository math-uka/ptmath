<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>培道中學數學組 - 對稱圖形設計.3</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            font-family: Arial, sans-serif;
            margin: 0;
            min-height: 100vh;
        }
        h1 {
            text-align: center;
            font-size: clamp(18px, 5vw, 24px);
            margin: 10px 0;
        }
        #canvas {
            border: 1px solid black;
            cursor: crosshair;
            transition: border-radius 0.3s;
            width: min(90vw, 500px);
            height: min(90vw, 500px);
            margin: 0 auto;
            touch-action: none;
        }
        #tools, #symmetryButtons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
        }
        button {
            padding: 8px;
            cursor: pointer;
            font-size: clamp(12px, 3vw, 16px);
            min-width: 60px;
        }
        #colorPicker {
            width: min(90vw, 160px);
            height: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
            gap: 2px;
            margin: 0 auto;
        }
        .colorBox {
            width: 100%;
            padding-top: 100%;
            position: relative;
            cursor: pointer;
            border: 1px solid #ccc;
        }
        .colorBox::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: inherit;
        }
        #currentColor {
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            margin: 10px auto;
        }
        @media (min-width: 768px) {
            body {
                flex-direction: row;
                padding: 20px;
                gap: 20px;
            }
            #canvas {
                width: 500px;
                height: 500px;
            }
            #tools {
                flex-direction: column;
                justify-content: flex-start;
            }
            #colorPicker {
                width: 160px;
                height: 200px;
                grid-template-columns: repeat(8, 20px);
            }
            .colorBox {
                width: 20px;
                height: 20px;
                padding-top: 0;
            }
            #currentColor {
                width: 50px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <div>
        <h1>培道中學數學組 - 對稱圖形設計.3</h1>
        <label>選擇對稱軸數量:</label>
        <div id="symmetryButtons">
            <button onclick="setSymmetry(1)">1</button>
            <button onclick="setSymmetry(2)">2</button>
            <button onclick="setSymmetry(4)">4</button>
            <button onclick="setSymmetry(6)">6</button>
            <button onclick="setSymmetry(8)">8</button>
            <button onclick="setSymmetry(10)">10</button>
        </div>
        <button onclick="resetCanvas()">重新作畫</button>
        <button onclick="undoLastStep()">上一步</button>
        <br><br>
        <button onclick="setCanvasShape('square')">正方形畫框</button>
        <button onclick="setCanvasShape('circle')">圓形畫框</button>
        <br><br>
        <button id="toggleAxes" onclick="toggleSymmetryAxes()">顯示對稱軸</button>
    </div>
    <canvas id="canvas"></canvas>
    <div id="tools">
        <button onclick="setShape('heart')">心形</button>
        <button onclick="setShape('star')">星形</button>
        <button onclick="setShape('triangle')">三角形</button>
        <button onclick="setShape('circle')">圓形</button>
        <button onclick="setShape('line')">直線</button>
        <button onclick="setShape('free')">自由繪畫</button>
        <div>顏色選擇:</div>
        <div id="colorPicker"></div>
        <div>當前顏色:</div>
        <div id="currentColor"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let symmetry = 1;
        let drawing = false;
        let shape = 'free';
        let points = [];
        let startX, startY, scale = 1;
        let endX, endY;
        let currentColor = '#000000';
        let showAxes = false;
        let drawings = [];
        let history = [];
        const maxHistorySteps = 10;
        const currentColorDisplay = document.getElementById('currentColor');

        // 動態設置canvas大小
        function resizeCanvas() {
            const size = Math.min(window.innerWidth * 0.9, 500);
            canvas.width = size;
            canvas.height = size;
            redrawCanvas();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 生成顏色
        const colors = [];
        for (let r = 0; r < 8; r++) {
            for (let g = 0; g < 4; g++) {
                for (let b = 0; b < 2; b++) {
                    colors.push(`#${(r*32).toString(16).padStart(2,'0')}${(g*64).toString(16).padStart(2,'0')}${(b*128).toString(16).padStart(2,'0')}`);
                }
            }
        }
        for (let i = 0; i < 8; i++) {
            const gray = Math.floor(i * 255 / 7).toString(16).padStart(2, '0');
            colors.push(`#${gray}${gray}${gray}`);
        }

        const colorPicker = document.getElementById('colorPicker');
        colors.forEach(color => {
            const div = document.createElement('div');
            div.className = 'colorBox';
            div.style.backgroundColor = color;
            div.onclick = () => {
                currentColor = color;
                currentColorDisplay.style.backgroundColor = color;
            };
            colorPicker.appendChild(div);
        });
        currentColorDisplay.style.backgroundColor = currentColor;

        function setSymmetry(num) {
            symmetry = num;
            redrawCanvas();
        }

        function resetCanvas() {
            drawings = [];
            history = [];
            redrawCanvas();
        }

        function setShape(newShape) {
            shape = newShape;
        }

        function setCanvasShape(shape) {
            canvas.style.borderRadius = shape === 'circle' ? '50%' : '0';
        }

        function toggleSymmetryAxes() {
            showAxes = !showAxes;
            document.getElementById('toggleAxes').textContent = showAxes ? '隱藏對稱軸' : '顯示對稱軸';
            redrawCanvas();
        }

        // 上一步功能
        function undoLastStep() {
            if (history.length > 0) {
                drawings = [...history.pop()];
                redrawCanvas();
            }
        }

        function saveToHistory() {
            if (history.length >= maxHistorySteps) {
                history.shift();
            }
            history.push([...drawings]);
        }

        function drawSymmetryAxes() {
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.strokeStyle = 'lightgreen';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;

            for (let i = 0; i < symmetry; i++) {
                ctx.beginPath();
                let angle = (i * Math.PI) / symmetry;
                if (symmetry === 1) angle = Math.PI / 2;
                ctx.moveTo(-canvas.width/2 * Math.cos(angle), -canvas.height/2 * Math.sin(angle));
                ctx.lineTo(canvas.width/2 * Math.cos(angle), canvas.height/2 * Math.sin(angle));
                ctx.stroke();
            }

            ctx.setLineDash([]);
            ctx.restore();
        }

        function redrawCanvas(tempDrawing = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawings.forEach(draw => drawDrawing(draw));
            if (tempDrawing) {
                drawDrawing(tempDrawing); // 繪製臨時圖形
            }
            if (showAxes) drawSymmetryAxes();
        }

        function drawDrawing({ shape, points, color, scale, angle }) {
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.fillStyle = color;
            ctx.strokeStyle = color;

            for (let i = 0; i < symmetry; i++) {
                ctx.rotate((2 * Math.PI) / symmetry);
                drawShape(shape, points, scale, color, angle);
                ctx.scale(-1, 1);
                drawShape(shape, points, scale, color, angle);
                ctx.scale(-1, 1);
            }

            ctx.restore();
        }

        // 獲取坐標
        function getCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: touch.clientX - rect.left - canvas.width / 2,
                y: touch.clientY - rect.top - canvas.height / 2
            };
        }

        // 開始繪畫
        function startDrawing(e) {
            e.preventDefault();
            drawing = true;
            const { x, y } = getCoordinates(e);
            startX = x;
            startY = y;
            points = [{ x, y }];
        }

        // 移動時繪畫
        function drawWhileMoving(e) {
            if (!drawing) return;
            e.preventDefault();
            const { x, y } = getCoordinates(e);
            points.push({ x, y });

            let tempDrawing = {
                shape,
                points: [...points],
                color: currentColor,
                scale: shape === 'free' ? 1 : Math.sqrt((x - startX) ** 2 + (y - startY) ** 2) / 15,
                angle: shape === 'line' ? Math.atan2(y - startY, x - startX) : 0
            };
            redrawCanvas(tempDrawing); // 重繪所有內容並顯示當前臨時圖形
        }

        // 結束繪畫
        function stopDrawing(e) {
            if (!drawing) return;
            drawing = false;
            const { x, y } = getCoordinates(e);
            points.push({ x, y });

            let angle = shape === 'line' ? Math.atan2(y - startY, x - startX) : 0;
            let finalScale = shape === 'free' ? 1 : Math.sqrt((x - startX) ** 2 + (y - startY) ** 2) / 15;

            saveToHistory();
            drawings.push({
                shape,
                points: [...points],
                color: currentColor,
                scale: finalScale,
                angle
            });

            points = [];
            scale = 1;
            endX = null;
            endY = null;
            redrawCanvas();
        }

        // 滑鼠事件
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', drawWhileMoving);
        canvas.addEventListener('mouseup', stopDrawing);

        // 觸控事件
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', drawWhileMoving);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', () => {
            drawing = false;
            points = [];
            scale = 1;
            endX = null;
            endY = null;
            redrawCanvas();
        });

        function drawShape(shapeType, points, scale, color, angle = 0) {
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.strokeStyle = color;

            if (shapeType === 'free') {
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            } else {
                ctx.save();
                ctx.translate(points[0].x, points[0].y);
                if (shapeType === 'line') ctx.rotate(angle);
                
                if (shapeType === 'heart') {
                    ctx.scale(scale, scale);
                    ctx.moveTo(0, 10);
                    ctx.bezierCurveTo(-15, -10, -5, -20, 0, 0);
                    ctx.bezierCurveTo(5, -20, 15, -10, 0, 10);
                    ctx.fill();
                } else if (shapeType === 'star') {
                    ctx.scale(scale, scale);
                    for (let i = 0; i < 5; i++) {
                        ctx.lineTo(15 * Math.cos((18 + i * 72) * Math.PI / 180), 
                                 15 * Math.sin((18 + i * 72) * Math.PI / 180));
                        ctx.lineTo(7 * Math.cos((54 + i * 72) * Math.PI / 180), 
                                 7 * Math.sin((54 + i * 72) * Math.PI / 180));
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (shapeType === 'triangle') {
                    ctx.scale(scale, scale);
                    ctx.moveTo(0, -10);
                    ctx.lineTo(-10, 10);
                    ctx.lineTo(10, 10);
                    ctx.closePath();
                    ctx.fill();
                } else if (shapeType === 'circle') {
                    ctx.scale(scale, scale);
                    ctx.arc(0, 0, 10, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (shapeType === 'line') {
                    ctx.scale(scale, scale);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(15, 0);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }
    </script>
</body>
</html>
