<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>多張圖轉GIF — 真正所見即所得（2025終極穩定版＋每張獨立時間）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body {font-family: Arial, "Microsoft JhengHei", sans-serif; max-width:940px; margin:40px auto; padding:20px; background:#f5f5f5; line-height:1.6;}
  h1 {text-align:center; color:#333;}
  .upload {border:3px dashed #999; padding:40px; text-align:center; background:white; border-radius:12px; margin:20px 0;}
  .thumbs {display:flex; justify-content:center; gap:15px; flex-wrap:wrap; margin:30px 0;}
  .thumb-wrapper {text-align:center; width:130px;}
  .thumb-wrapper img {max-width:120px; max-height:120px; border:2px solid #ddd; border-radius:8px; object-fit:contain; background:#fff;}
  .thumb-wrapper input {width:80px; margin-top:6px;}
  .status {text-align:center; font-size:19px; margin:20px; padding:15px; border-radius:8px;}
  .waiting {background:#fff3cd; color:#856404;}
  .ready {background:#d4edda; color:#155724;}
  .controls {text-align:center; margin:30px;}
  button {padding:15px 40px; font-size:20px; background:#28a745; color:white; border:none; border-radius:8px; cursor:pointer;}
  button:hover {background:#218838;}
  button:disabled {background:#ccc; cursor:not-allowed;}
  #previewContainer {text-align:center; margin:40px auto; max-width:100%;}
  #gifPreview {max-width:100%; height:auto; border:5px solid #28a745; border-radius:12px; background:#000; cursor:pointer; box-shadow:0 8px 25px rgba(0,0,0,0.3);}
  #error {background:#f8d7da; color:#721c24; padding:10px; border-radius:5px; margin:10px; display:none;}
</style>
</head>
<body>
<h1>多張圖轉GIF — 真正所見即所得（2025終極穩定版）</h1>
<div class="upload">
  <p>一次選多張圖片（建議最多20張，小圖優先）<br>自動保持原始比例＋淡入淡出＋<strong>每張圖可獨立設定時間！</strong></p>
  <input type="file" id="files" accept="image/*" multiple>
  <br><br><button id="clear">清空重來</button>
</div>

<div id="error"></div>

<div class="thumbs" id="thumbs"></div>

<div id="previewContainer">
  <h3>即時預覽（點擊播放／暫停）</h3>
  <img id="gifPreview" src="" alt="預覽載入中…" style="display:none;">
  <p id="tip" style="color:#666; font-size:18px;">上傳圖片後，這裡會出現跟最終檔案一模一樣的動畫～</p>
</div>

<div class="status waiting" id="msg">請上傳圖片…</div>

<div class="controls">
  全域每幀時間 <input type="number" id="ms" value="600" min="50" max="5000" style="width:100px;"> ms
  （調整此值會同步未手動修改的圖片）
  <br><br>
  <label><input type="checkbox" id="loop" checked> 循環播放</label>
  <label style="margin-left:20px;"><input type="checkbox" id="trans" checked> 透明補白</label>
  <label style="margin-left:20px;"><input type="checkbox" id="crossfade" checked> 淡入淡出轉場（超推薦）</label>
  <br><br>
  <button id="btn" disabled>生成並下載 最高品質 GIF</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
<script>
const input = document.getElementById('files');
const thumbs = document.getElementById('thumbs');
const gifPreview = document.getElementById('gifPreview');
const tip = document.getElementById('tip');
const btn = document.getElementById('btn');
const msg = document.getElementById('msg');
const errorDiv = document.getElementById('error');
let centeredFrames = [];     // 置中補白後的 base64
let frameDelays = [];        // 每張圖各自的顯示時間（ms）
let canvasSize = {w:800, h:600};
let gif = null;

const fileToBase64 = file => new Promise(r => {const fr=new FileReader(); fr.onload=()=>r(fr.result); fr.readAsDataURL(file);});
const waitImg = src => new Promise((r, rej) => {const i=new Image(); i.onload=() => r(i); i.onerror=() => rej(new Error('Image load failed: ' + src)); i.src=src;});

async function calcCanvas(files) {
  let mw=0, mh=0;
  for (const f of files) {
    const b64 = await fileToBase64(f);
    try {
      const img = await waitImg(b64);
      mw = Math.max(mw, img.naturalWidth);
      mh = Math.max(mh, img.naturalHeight);
    } catch (e) {
      console.error('Canvas calc error:', e);
    }
  }
  const target = 800;
  canvasSize = mw > mh
    ? {w: target, h: Math.round(target * mh / mw)}
    : {w: Math.round(target * mw / mh), h: target};
  console.log('Canvas size calculated:', canvasSize);
}

function createCenteredCanvas(b64, useTrans) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => {
      const c = document.createElement('canvas');
      c.width = canvasSize.w;
      c.height = canvasSize.h;
      const ctx = c.getContext('2d');
      // 背景：透明或白色
      ctx.fillStyle = useTrans ? 'rgba(0,0,0,0)' : '#ffffff';
      ctx.fillRect(0, 0, c.width, c.height);
      // 置中繪製
      const scale = Math.min(c.width / img.naturalWidth, c.height / img.naturalHeight);
      const w = img.naturalWidth * scale, h = img.naturalHeight * scale;
      ctx.drawImage(img, (c.width - w) / 2, (c.height - h) / 2, w, h);
      console.log('Canvas created successfully for frame');
      res(c);  // 返回 canvas 元素
    };
    img.onerror = rej;
    img.src = b64;
  });
}

async function crossfadeCanvas(c1, c2, steps = 10) {
  const frames = [];
  const tempC = document.createElement('canvas');
  tempC.width = canvasSize.w;
  tempC.height = canvasSize.h;
  const ctx = tempC.getContext('2d');
  const useTrans = document.getElementById('trans').checked;
  for (let i = 1; i <= steps; i++) {
    ctx.clearRect(0, 0, tempC.width, tempC.height);
    if (useTrans) {
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0, 0, tempC.width, tempC.height);
    } else {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, tempC.width, tempC.height);
    }
    ctx.globalAlpha = 1 - i / steps;
    ctx.drawImage(c1, 0, 0);
    ctx.globalAlpha = i / steps;
    ctx.drawImage(c2, 0, 0);
    ctx.globalAlpha = 1;
    frames.push(tempC);  // 收集 canvas
  }
  console.log(`Crossfade generated ${steps} frames`);
  return frames;
}

function showError(msg) {
  errorDiv.textContent = msg;
  errorDiv.style.display = 'block';
  msg.className = 'status waiting';
  console.error('Error:', msg);
}

async function makePreview() {
  if (centeredFrames.length === 0) return;
  tip.textContent = '正在產生預覽，請稍候…';
  errorDiv.style.display = 'none';

  try {
    const useTrans = document.getElementById('trans').checked;
    const canvases = await Promise.all(centeredFrames.map(b64 => createCenteredCanvas(b64, useTrans)));
    console.log('All main canvases ready');

    gif = new GIF({
      workers: 2,
      quality: 10,
      width: canvasSize.w,
      height: canvasSize.h,
      workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'
    });

    gif.on('progress', p => console.log('Preview progress:', p));
    gif.on('finished', blob => {
      gifPreview.src = URL.createObjectURL(blob);
      gifPreview.style.display = 'block';
      tip.innerHTML = `<strong style="color:#28a745;">預覽完成！點擊圖片播放／暫停（跟最終檔案 100% 一致）</strong>`;
    });

    const useCrossfade = document.getElementById('crossfade').checked;
    const steps = useCrossfade ? 8 : 0;

    for (let i = 0; i < canvases.length; i++) {
      gif.addFrame(canvases[i], {delay: frameDelays[i]});
      if (useCrossfade && i < canvases.length - 1) {
        const transFrames = await crossfadeCanvas(canvases[i], canvases[i + 1], steps);
        const transDelay = Math.floor(frameDelays[i] / (steps + 1));
        transFrames.forEach(t => gif.addFrame(t, {delay: transDelay}));
      }
    }

    if (useCrossfade && document.getElementById('loop').checked && centeredFrames.length > 1) {
      const backFrames = await crossfadeCanvas(canvases[canvases.length - 1], canvases[0], steps);
      const transDelay = Math.floor(frameDelays[canvases.length - 1] / (steps + 1));
      backFrames.forEach(t => gif.addFrame(t, {delay: transDelay}));
    }

    gif.setOptions({repeat: document.getElementById('loop').checked ? 0 : -1});
    gif.render();
    msg.textContent = '預覽產生中…';
    msg.className = 'status waiting';

  } catch (e) {
    showError('預覽產生失敗：' + e.message + '。請檢查 Console (F12) 錯誤，或試不同圖片格式 (PNG/JPG)。');
    console.error('Preview error details:', e);
  }
}

input.onchange = async () => {
  const files = Array.from(input.files);
  if (files.length < 2) return alert('至少要 2 張喔！');
  if (files.length > 20) return alert('建議最多 20 張，避免瀏覽器卡住');

  thumbs.innerHTML = ''; 
  centeredFrames = []; 
  frameDelays = [];
  gifPreview.style.display = 'none';
  msg.textContent = '圖片處理中…'; 
  msg.className = 'status waiting';
  errorDiv.style.display = 'none';

  await calcCanvas(files);
  const defaultMs = parseInt(document.getElementById('ms').value) || 600;

  for (let idx = 0; idx < files.length; idx++) {
    const file = files[idx];
    const raw = await fileToBase64(file);
    centeredFrames.push(raw);  // 存 raw base64
    frameDelays.push(defaultMs);

    const wrapper = document.createElement('div');
    wrapper.className = 'thumb-wrapper';

    const thumb = document.createElement('img');
    thumb.src = raw;  // 直接用 raw 顯示縮圖

    const delayInput = document.createElement('input');
    delayInput.type = 'number';
    delayInput.min = 50;
    delayInput.max = 5000;
    delayInput.value = defaultMs;
    delayInput.dataset.index = idx;

    delayInput.addEventListener('input', function() {
      const val = parseInt(this.value) || defaultMs;
      if (val >= 50) frameDelays[idx] = val;
    });

    delayInput.addEventListener('change', () => {
      msg.textContent = '時間變更，重新產生預覽…';
      makePreview();
    });

    const label = document.createTextNode(' ms');
    wrapper.appendChild(thumb);
    wrapper.appendChild(delayInput);
    wrapper.appendChild(label);
    thumbs.appendChild(wrapper);
  }

  msg.textContent = '已載入完成，正在產生預覽…';
  await makePreview();
  btn.disabled = false;
  msg.className = 'status ready';
};

document.getElementById('ms').addEventListener('change', function() {
  const global = parseInt(this.value) || 600;
  let changed = false;
  document.querySelectorAll('#thumbs input[type=number]').forEach(inp => {
    const idx = parseInt(inp.dataset.index);
    if (frameDelays[idx] === (parseInt(inp.value) || 600)) {
      inp.value = global;
      frameDelays[idx] = global;
      changed = true;
    }
  });
  if (changed && centeredFrames.length > 0) {
    msg.textContent = '全域時間變更，重新產生預覽…';
    makePreview();
  }
});

['crossfade', 'loop'].forEach(id => {
  document.getElementById(id).onchange = () => {
    if (centeredFrames.length > 0) {
      msg.textContent = '參數變更，重新產生預覽…';
      makePreview();
    }
  };
});

document.getElementById('trans').onchange = () => {
  if (centeredFrames.length > 0) {
    input.onchange();  // 透明變更需重置 canvas
  }
};

gifPreview.onclick = () => {
  if (gifPreview.src) gifPreview.src = gifPreview.src.split('?')[0] + '?t=' + Date.now();
};

btn.onclick = async () => {
  if (centeredFrames.length === 0) return showError('無圖片，請先上傳');

  btn.disabled = true; 
  btn.textContent = '最終渲染中… 0%';
  errorDiv.style.display = 'none';

  try {
    const useTrans = document.getElementById('trans').checked;
    const canvases = await Promise.all(centeredFrames.map(b64 => createCenteredCanvas(b64, useTrans)));

    const finalGif = new GIF({
      workers: 3,
      quality: 5,  // 更高品質
      width: canvasSize.w,
      height: canvasSize.h,
      workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'
    });

    finalGif.on('progress', p => btn.textContent = `最終渲染中… ${Math.round(p * 100)}%`);
    finalGif.on('finished', blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const useCrossfade = document.getElementById('crossfade').checked;
      a.download = useCrossfade
        ? `淡入淡出_自訂時間_${centeredFrames.length}張.gif`
        : `完美比例_自訂時間_${centeredFrames.length}幀.gif`;
      a.click();
      btn.textContent = '下載完成！再做一個？';
      setTimeout(() => { btn.disabled = false; btn.textContent = '生成並下載 最高品質 GIF'; }, 3000);
    });

    const useCrossfade = document.getElementById('crossfade').checked;
    const steps = useCrossfade ? 12 : 0;

    for (let i = 0; i < canvases.length; i++) {
      finalGif.addFrame(canvases[i], {delay: frameDelays[i]});

      if (useCrossfade && i < canvases.length - 1) {
        const transFrames = await crossfadeCanvas(canvases[i], canvases[i + 1], steps);
        const transDelay = Math.floor(frameDelays[i] / (steps + 1));
        transFrames.forEach(t => finalGif.addFrame(t, {delay: transDelay}));
      }
    }

    if (useCrossfade && document.getElementById('loop').checked && centeredFrames.length > 1) {
      const backFrames = await crossfadeCanvas(canvases[canvases.length - 1], canvases[0], steps);
      const transDelay = Math.floor(frameDelays[canvases.length - 1] / (steps + 1));
      backFrames.forEach(t => finalGif.addFrame(t, {delay: transDelay}));
    }

    finalGif.setOptions({repeat: document.getElementById('loop').checked ? 0 : -1});
    finalGif.render();

  } catch (e) {
    showError('最終生成失敗：' + e.message + '。請檢查 Console (F12)。');
    btn.disabled = false;
    btn.textContent = '生成並下載 最高品質 GIF';
    console.error('Final error details:', e);
  }
};

document.getElementById('clear').onclick = () => location.reload();
</script>

<p style="text-align:center; color:#28a745; font-size:20px; margin-top:60px; font-weight:bold;">
  2025 終極穩定版：<br>
  修復 "Invalid image" 錯誤！用 Canvas 元素確保兼容。<br>
  預覽 = 最終成品（尺寸、比例、轉場、每張圖時間 100% 一致）<br>
  每張圖獨立時間，手機電腦完美運行，淡入淡出超順滑！
</p>
</body>
</html>
