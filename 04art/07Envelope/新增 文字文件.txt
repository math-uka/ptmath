<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>繡曲線生成器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
        .controls {
            margin: 20px;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        label {
            margin-right: 10px;
            font-size: 16px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        input[type="color"] {
            width: 50px;
            height: 30px;
            padding: 2px;
            border: none;
            cursor: pointer;
        }
        #generator-container, #composition-container {
            margin: 20px;
        }
        #composition-container {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <h1>繡曲線生成器</h1>
    <div class="controls">
        <div class="control-group">
            <label for="lineCount">線條數量: </label>
            <input type="range" id="lineCount" min="1" max="50" value="5">
            <span id="lineCountValue">5</span>
        </div>
        <div class="control-group">
            <label for="axisCount">軸數量: </label>
            <input type="range" id="axisCount" min="3" max="10" value="3">
            <span id="axisCountValue">3</span>
        </div>
        <div class="control-group">
            <label for="zoom">縮放: </label>
            <input type="range" id="zoom" min="0.5" max="2" step="0.1" value="1">
            <span id="zoomValue">1</span>
        </div>
        <div class="control-group">
            <label for="rotation">旋轉: </label>
            <input type="range" id="rotation" min="0" max="360" value="0">
            <span id="rotationValue">0</span>
        </div>
        <div class="control-group">
            <label for="lineColor">線條顏色: </label>
            <input type="color" id="lineColor" value="#0000ff">
        </div>
        <div class="control-group">
            <button id="toggleAxes">隱藏數軸</button>
            <button id="download">下載圖案</button>
            <button id="toggleMode">切換為多邊形模式</button>
            <button id="import">導入到組合畫框</button>
            <button id="export">導出組合圖畫</button>
        </div>
    </div>
    <div id="generator-container"></div>
    <h2>組合畫框（拖動移動，按住 Shift + 拖動旋轉）</h2>
    <div id="composition-container"></div>
    <script>
        // 禁用右鍵
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            alert('右鍵功能已被禁用！');
        });

        // 禁用 F12、Ctrl+U、Ctrl+S 等快捷鍵
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F12' ||
                (e.ctrlKey && (e.key === 'u' || e.key === 'U' || e.key === 's' || e.key === 'S'))) {
                e.preventDefault();
                alert('此快捷鍵已被禁用！');
            }
        });

        let gen;
        let comp;

        let generatorSketch = function(p) {
            let lineCount = 5;
            let axisCount = 3;
            const maxValue = 10; // 固定最大值為 10
            let showAxes = true; // 控制數軸顯示狀態
            let lineColor = [0, 0, 255]; // 初始藍色
            let polygonMode = false; // 控制數軸模式（false: 輻射, true: 多邊形）
            let zoomLevel = 1; // 初始縮放級別
            let rotationAngle = 0; // 初始旋轉角度

            p.setup = function() {
                let canvas = p.createCanvas(600, 600);
                canvas.parent('generator-container');
                canvas.style('background-color', 'transparent'); // 確保畫布背景透明

                // 線條數量滑條
                let lineSlider = document.getElementById('lineCount');
                let lineSliderValue = document.getElementById('lineCountValue');
                lineSlider.oninput = function() {
                    lineCount = parseInt(this.value);
                    lineSliderValue.textContent = lineCount;
                };

                // 軸數量滑條
                let axisSlider = document.getElementById('axisCount');
                let axisSliderValue = document.getElementById('axisCountValue');
                axisSlider.oninput = function() {
                    axisCount = parseInt(this.value);
                    axisSliderValue.textContent = axisCount;
                };

                // 縮放滑條
                let zoomSlider = document.getElementById('zoom');
                let zoomSliderValue = document.getElementById('zoomValue');
                zoomSlider.oninput = function() {
                    zoomLevel = parseFloat(this.value);
                    zoomSliderValue.textContent = zoomLevel.toFixed(1);
                };

                // 旋轉滑條
                let rotationSlider = document.getElementById('rotation');
                let rotationSliderValue = document.getElementById('rotationValue');
                rotationSlider.oninput = function() {
                    rotationAngle = parseFloat(this.value);
                    rotationSliderValue.textContent = rotationAngle.toFixed(0);
                };

                // 線條顏色選擇器
                let colorPicker = document.getElementById('lineColor');
                colorPicker.oninput = function() {
                    let hex = this.value;
                    lineColor = [
                        parseInt(hex.substr(1, 2), 16),
                        parseInt(hex.substr(3, 2), 16),
                        parseInt(hex.substr(5, 2), 16)
                    ];
                };

                // 顯示/隱藏數軸按鈕
                let toggleButton = document.getElementById('toggleAxes');
                toggleButton.onclick = function() {
                    showAxes = !showAxes;
                    toggleButton.textContent = showAxes ? '隱藏數軸' : '顯示數軸';
                };

                // 下載圖案按鈕
                let downloadButton = document.getElementById('download');
                downloadButton.onclick = function() {
                    p.saveCanvas('繡曲線圖案', 'png'); // 下載畫布為 PNG，保留透明背景
                };

                // 切換數軸模式按鈕
                let modeButton = document.getElementById('toggleMode');
                modeButton.onclick = function() {
                    polygonMode = !polygonMode;
                    modeButton.textContent = polygonMode ? '切換為輻射模式' : '切換為多邊形模式';
                };
            };

            p.draw = function() {
                // 清除畫布但不填充背景，保持透明
                p.clear();
                // 計算畫布邊界
                let padding = 50;
                let canvasSize = 500 * zoomLevel; // 應用縮放
                let scale = canvasSize / maxValue; // 固定縮放比例
                let centerX = p.width / 2;
                let centerY = p.height / 2;
                let radius = canvasSize / 2; // 多邊形半徑

                // 應用旋轉
                p.push();
                p.translate(centerX, centerY);
                p.rotate(p.radians(rotationAngle));
                p.translate(-centerX, -centerY);

                // 繪製數軸（如果 showAxes 為 true）
                if (showAxes) {
                    p.stroke(0);
                    p.strokeWeight(2);
                    let vertices = []; // 儲存多邊形頂點
                    for (let i = 0; i < axisCount; i++) {
                        let angle = (i / axisCount) * p.TWO_PI - p.PI / 2; // 從頂部開始
                        let x = centerX + p.cos(angle) * radius;
                        let y = centerY + p.sin(angle) * radius;
                        vertices.push([x, y]);
                    }

                    if (polygonMode) {
                        // 多邊形模式：每條數軸為多邊形的一條邊
                        for (let i = 0; i < axisCount; i++) {
                            let startX = vertices[i][0];
                            let startY = vertices[i][1];
                            let endX = vertices[(i + 1) % axisCount][0];
                            let endY = vertices[(i + 1) % axisCount][1];
                            p.line(startX, startY, endX, endY); // 繪製多邊形邊作為數軸

                            // 繪製刻度和標籤
                            for (let j = 1; j <= maxValue; j++) {
                                let t = j / maxValue;
                                let tickX = p.lerp(startX, endX, t);
                                let tickY = p.lerp(startY, endY, t);
                                let tickSize = 5;
                                let angle = p.atan2(endY - startY, endX - startX);
                                let tickAngle = angle + p.PI / 2; // 垂直於軸
                                p.line(
                                    tickX + p.cos(tickAngle) * tickSize,
                                    tickY + p.sin(tickAngle) * tickSize,
                                    tickX - p.cos(tickAngle) * tickSize,
                                    tickY - p.sin(tickAngle) * tickSize
                                );
                                // 標籤
                                p.textAlign(p.CENTER, p.CENTER);
                                p.textSize(12);
                                p.text(j, tickX + p.cos(tickAngle) * 15, tickY + p.sin(tickAngle) * 15);
                            }
                        }
                    } else {
                        // 輻射模式：數軸從中心輻射
                        for (let i = 0; i < axisCount; i++) {
                            let angle = (i / axisCount) * p.TWO_PI;
                            let x2 = centerX + p.cos(angle) * radius;
                            let y2 = centerY + p.sin(angle) * radius;
                            p.line(centerX, centerY, x2, y2); // 從中心點繪製軸

                            // 繪製刻度和標籤
                            for (let j = 1; j <= maxValue; j++) {
                                let t = j / maxValue;
                                let tickX = centerX + p.cos(angle) * t * radius;
                                let tickY = centerY + p.sin(angle) * t * radius;
                                let tickSize = 5;
                                let tickAngle = angle + p.PI / 2;
                                p.line(
                                    tickX + p.cos(tickAngle) * tickSize,
                                    tickY + p.sin(tickAngle) * tickSize,
                                    tickX - p.cos(tickAngle) * tickSize,
                                    tickY - p.sin(tickAngle) * tickSize
                                );
                                p.textAlign(p.CENTER, p.CENTER);
                                p.textSize(12);
                                p.text(j, tickX + p.cos(tickAngle) * 15, tickY + p.sin(tickAngle) * 15);
                            }
                        }
                    }
                }

                // 繪製繡曲線（始終顯示）
                p.stroke(lineColor[0], lineColor[1], lineColor[2]);
                p.strokeWeight(1);
                let vertices = []; // 儲存多邊形頂點（用於繡曲線計算）
                for (let i = 0; i < axisCount; i++) {
                    let angle = (i / axisCount) * p.TWO_PI - p.PI / 2;
                    let x = centerX + p.cos(angle) * radius;
                    let y = centerY + p.sin(angle) * radius;
                    vertices.push([x, y]);
                }

                for (let i = 0; i < lineCount; i++) {
                    let t = i / (lineCount - 1 || 1); // 均勻插值
                    if (polygonMode) {
                        // 多邊形模式：點1連點1，點2連點2
                        for (let j = 0; j < axisCount; j++) {
                            let startAxis = j;
                            let endAxis = (j + 1) % axisCount;
                            let startX = vertices[startAxis][0];
                            let startY = vertices[startAxis][1];
                            let endX = vertices[endAxis][0];
                            let endY = vertices[endAxis][1];
                            // 計算當前邊上的插值點
                            let x1 = p.lerp(startX, endX, t);
                            let y1 = p.lerp(startY, endY, t);
                            // 計算下一邊上的相同插值點
                            let nextStartAxis = (j + 1) % axisCount;
                            let nextEndAxis = (j + 2) % axisCount;
                            let nextStartX = vertices[nextStartAxis][0];
                            let nextStartY = vertices[nextStartAxis][1];
                            let nextEndX = vertices[nextEndAxis][0];
                            let nextEndY = vertices[nextEndAxis][1];
                            let x2 = p.lerp(nextStartX, nextEndX, t);
                            let y2 = p.lerp(nextStartY, nextEndY, t);
                            // 連線相同插值點
                            p.line(x1, y1, x2, y2);
                        }
                    } else {
                        // 輻射模式：保持原邏輯
                        for (let j = 0; j < axisCount; j++) {
                            let startAxis = j;
                            let endAxis = (j + 1) % axisCount;
                            let startAngle = (startAxis / axisCount) * p.TWO_PI;
                            let endAngle = (endAxis / axisCount) * p.TWO_PI;
                            let value = maxValue * (1 - t);
                            let x1 = centerX + p.cos(startAngle) * value * scale / 2;
                            let y1 = centerY + p.sin(startAngle) * value * scale / 2;
                            let x2 = centerX + p.cos(endAngle) * (maxValue - value) * scale / 2;
                            let y2 = centerY + p.sin(endAngle) * (maxValue - value) * scale / 2;
                            p.line(x1, y1, x2, y2);
                        }
                    }
                }
                p.pop();
            };
        };

        gen = new p5(generatorSketch);

        let compositionSketch = function(p) {
            let elements = [];
            let selected = null;
            let offsetX, offsetY;
            let prevAngle = 0;

            p.setup = function() {
                let canvas = p.createCanvas(800, 800);
                canvas.parent('composition-container');
                canvas.style('background-color', 'transparent');
            };

            p.draw = function() {
                p.clear();
                for (let el of elements) {
                    p.push();
                    p.translate(el.x, el.y);
                    p.rotate(p.radians(el.rot));
                    p.image(el.img, -el.img.width / 2, -el.img.height / 2);
                    p.pop();
                }
            };

            p.mousePressed = function() {
                if (p.mouseX < 0 || p.mouseX > p.width || p.mouseY < 0 || p.mouseY > p.height) return;
                for (let i = elements.length - 1; i >= 0; i--) {
                    let el = elements[i];
                    // 轉換鼠標到本地坐標系
                    let mx = p.mouseX - el.x;
                    let my = p.mouseY - el.y;
                    let rot = -p.radians(el.rot);
                    let lx = mx * p.cos(rot) - my * p.sin(rot);
                    let ly = mx * p.sin(rot) + my * p.cos(rot);
                    if (Math.abs(lx) < el.img.width / 2 && Math.abs(ly) < el.img.height / 2) {
                        selected = el;
                        offsetX = p.mouseX - el.x;
                        offsetY = p.mouseY - el.y;
                        let dx = p.mouseX - el.x;
                        let dy = p.mouseY - el.y;
                        prevAngle = p.atan2(dy, dx);
                        break;
                    }
                }
            };

            p.mouseDragged = function() {
                if (selected) {
                    if (p.keyIsDown(16)) { // 16 is SHIFT
                        let dx = p.mouseX - selected.x;
                        let dy = p.mouseY - selected.y;
                        let angle = p.atan2(dy, dx);
                        let delta = angle - prevAngle;
                        selected.rot += p.degrees(delta);
                        prevAngle = angle;
                    } else {
                        selected.x = p.mouseX - offsetX;
                        selected.y = p.mouseY - offsetY;
                    }
                }
            };

            p.mouseReleased = function() {
                selected = null;
            };

            p.addElement = function(img) {
                elements.push({ img: img, x: p.width / 2, y: p.height / 2, rot: 0 });
            };

            p.exportCanvas = function() {
                p.saveCanvas('組合圖畫', 'png');
            };
        };

        comp = new p5(compositionSketch);

        // 導入按鈕
        document.getElementById('import').onclick = function() {
            let img = gen.get();
            comp.addElement(img);
        };

        // 導出按鈕
        document.getElementById('export').onclick = function() {
            comp.exportCanvas();
        };
    </script>
</body>
</html>