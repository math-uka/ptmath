<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>數學作業</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        .question-container {
            margin-bottom: 20px;
        }
        .question {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        .input-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .prefix {
            margin-right: 10px;
        }
        .answer {
            margin-top: 10px;
            color: green;
        }
        .tutorial {
            margin-top: 10px;
            color: #333;
            font-style: italic;
        }
        .tutorial p {
            margin: 0 0 10px 0;
        }
        .source-file {
            font-weight: bold;
            color: #555;
            margin-bottom: 10px;
        }
        #error {
            color: red;
        }
    </style>
</head>
<body>
    <h1 id="homework-title">數學作業集合</h1>
    <div id="error"></div>
    <div id="questions"></div>

    <script>
        // List of JSON files to load
        const jsonFiles = ['hw.json', 'hw2.json', 'hw3.json', 'hwh.json'];

        // Function to generate questions for a single file
        function generateQuestions(data, filename, questionsDiv) {
            // Create a div for the file's questions
            const fileSection = document.createElement('div');
            fileSection.className = 'file-section';

            // Add source file name
            const sourceDiv = document.createElement('div');
            sourceDiv.className = 'source-file';
            sourceDiv.textContent = `題目來源: ${filename}`;
            fileSection.appendChild(sourceDiv);

            // Generate questions
            data.questions.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question-container';

                // Annotation
                const annotation = document.createElement('h3');
                annotation.textContent = q.annotation;
                questionDiv.appendChild(annotation);

                // Question
                const question = document.createElement('div');
                question.className = 'question';
                question.textContent = q.question;
                questionDiv.appendChild(question);

                // Input fields with prefixes
                if (Array.isArray(q.prefix)) {
                    q.prefix.forEach((prefix, i) => {
                        const inputGroup = document.createElement('div');
                        inputGroup.className = 'input-group';
                        const prefixSpan = document.createElement('span');
                        prefixSpan.className = 'prefix';
                        prefixSpan.textContent = prefix;
                        inputGroup.appendChild(prefixSpan);
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.value = q.answers[i] || '';
                        inputGroup.appendChild(input);
                        questionDiv.appendChild(inputGroup);
                    });
                } else {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';
                    const prefixSpan = document.createElement('span');
                    prefixSpan.className = 'prefix';
                    prefixSpan.textContent = q.prefix;
                    inputGroup.appendChild(prefixSpan);
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = q.answers[0] || '';
                    inputGroup.appendChild(input);
                    questionDiv.appendChild(inputGroup);
                }

                // Answers using answerlatex for MathJax rendering
                const answerDiv = document.createElement('div');
                answerDiv.className = 'answer';
                answerDiv.textContent = '答案: ';
                if (Array.isArray(q.answerlatex)) {
                    q.answerlatex.forEach((latex, i) => {
                        const latexSpan = document.createElement('span');
                        latexSpan.textContent = latex;
                        answerDiv.appendChild(latexSpan);
                        if (i < q.answerlatex.length - 1) {
                            answerDiv.appendChild(document.createTextNode(', '));
                        }
                    });
                } else {
                    const latexSpan = document.createElement('span');
                    latexSpan.textContent = q.answerlatex;
                    answerDiv.appendChild(latexSpan);
                }
                questionDiv.appendChild(answerDiv);

                // Tutorial (if exists)
                if (q.tutorial) {
                    const tutorialDiv = document.createElement('div');
                    tutorialDiv.className = 'tutorial';
                    const paragraphs = q.tutorial.split('\n\n');
                    paragraphs.forEach(paragraph => {
                        const p = document.createElement('p');
                        p.textContent = paragraph;
                        tutorialDiv.appendChild(p);
                    });
                    questionDiv.appendChild(tutorialDiv);
                }

                fileSection.appendChild(questionDiv);
            });

            questionsDiv.appendChild(fileSection);
        }

        // Fetch all JSON files
        const questionsDiv = document.getElementById('questions');
        const fetchPromises = jsonFiles.map(filename => 
            fetch(filename)
                .then(response => {
                    if (!response.ok) {
                        return null; // Skip failed fetches
                    }
                    return response.json().then(data => ({ data, filename }));
                })
                .catch(() => null) // Suppress errors for individual files
        );

        Promise.all(fetchPromises).then(results => {
            // Filter out null results and process valid data
            results.filter(result => result !== null).forEach(({ data, filename }) => {
                generateQuestions(data, filename, questionsDiv);
            });

            // Re-render MathJax after adding content
            MathJax.typeset();

            // If no files were loaded successfully
            if (!results.some(result => result !== null)) {
                document.getElementById('error').textContent = '無任何作業文件可加載';
            }
        });
    </script>
</body>
</html>